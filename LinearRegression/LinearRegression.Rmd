---
title: "Simple Linear Regression Assignment Solutions"
author: "Haroon Ahmed"
date: "11 June 2017"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
---

Clear your environment

```{r}

rm(list = ls(all=TRUE))

```

# Combined Cycle Power Plant Data Set

The dataset given to you has been collected from a **Combined Cycle Power Plant** over 6 years (2006-2011).

A combined cycle power plant (CCPP) is composed of gas turbines (GT), steam turbines (ST) and heat recovery steam generators. In a CCPP, the electricity is generated by gas and steam turbines, which are combined in one cycle, and is transferred from one turbine to another. While the Vacuum is colected from and has effect on the Steam Turbine, the other three of the ambient variables effect the GT performance.

The variables in the dataset are as follows:

* __AmbTemp__ :  Hourly average of ambient Temperature at the plant (Range 1.81°C and 37.11°C)


* __Exvac__ : Exhaust Vacuum is pumps air out of the steam turbine (Range 25.36-81.56 cm Hg)


* __AmbPress__ : Hourly average of ambient Pressure at the plant (Range 992.89-1033.30 milibar)


* __RelHum__ : Hourly average of ambient relative humidity at the plant (Range 25.56% to 100.16%)


* __ElOut__ : Net hourly Electrical Energy Output of the plant (Range 420.26-495.76 MW)


# Agenda

* Get the data

* Ask interesting questions

* Explore the data

* Clean and Process the Data

* Model the data

* Evaluation and Communication


# Read the Data

* Read in the data and store it in a variable

```{r}

setwd("C:\\MOOC\\Insofe\\Module 1 - Probability and Statistics\\Linear Regression Module\\20170611_Batch29_CSE7202c_Sim_Lin_Regression_Assignment_Sols\\20170611_Batch29_CSE7202c_Sim_Lin_Regression_Assignment_Sols")
ccpp_data <- read.csv("ccpp.csv")

```

# Understand the Data

* How many Observations are there in the dataset? What are the data types of the variables?

```{r}

str(ccpp_data)
dim(ccpp_data)

```


* Get some descriptive statistics of the variables in the dataset

```{r}

summary(ccpp_data)
length(manyNAs(ccpp_data, 0.7) )
ccppNA <- ccpp_data[-manyNAs(ccpp_data),]

```

# Ask Some Questions

* How does the ambient temperature effect the electical energy output generation at the CCPP?

* ???

* ???


# Exploratory Analysis

* Plot the relationships between the explanatory and response variables

```{r}

par(mfrow = c(2,2))

plot(ccpp_data$AmbTemp, ccpp_data$ElOut, xlab = "Ambient Temperature", ylab = "Elec. Energy Output" , main = "Amb. Temp. vs Elec. Energy Output")

plot(ccpp_data$ExVac, ccpp_data$ElOut, xlab = "Exhaust Vacuum", ylab = "Elec. Energy Output" , main = "Vacuum vs Elec. Energy Output")

plot(ccpp_data$AmbPress, ccpp_data$ElOut, xlab = "Ambient Pressure", ylab = "Elec. Energy Output" , main = "Amb. Press. vs Elec. Energy Output")

plot(ccpp_data$RelHum, ccpp_data$ElOut, xlab = "Relative Humidity", ylab = "Elec. Energy Output" , main = "Rel. Hum. vs Elec. Energy Output")


```

* Plot a Correlation Plot

```{r}

library(corrplot)

corrplot(cor(ccpp_data, use = "complete.obs"), method = "number")
corrplot(cor(ccpp_data, use = "complete.obs"), method = "number", type = "lower")
corrplot(cor(ccpp_data, use = "complete.obs"), method = "number", type = "lower", sig.level = 0.05)

```

# Data Cleaning and Pre-Processing

* Are all the variables in the correct data type? 

* Do you need to convert the data type of any of the variables?

```{r}

# All variables are numeric, no need to convert any the data type of any variable?

str(ccpp_data)

```

* How many Missing Values does the dataset have? 

```{r}

sum(is.na(ccpp_data))

```

* Either remove or impute the missing values in the dataset

```{r}

ccpp_data <- na.omit(ccpp_data)
data3<-centralImputation(ccpp_data) 


```

* Standardize (Scale and Center) the explanatory variables

```{r}

ccpp_std <- scale(ccpp_data[, !(names(ccpp_data) %in% c("ElOut"))])

ccpp_data[, !(names(ccpp_data) %in% c("ElOut"))] <- ccpp_std

```

* Split the data into train and test data sets (70/30)

```{r}

set.seed(111)

train_rows <- sample(x = 1:nrow(ccpp_data), size = 0.7*nrow(ccpp_data))

train_data <- ccpp_data[train_rows, ]

test_data <- ccpp_data[-train_rows, ]


```


# Build Models

* Build four simple linear regression models

* Note down the coefficients, intercepts, R^2 and p-values of the models you built. 

* Plot the residual plots

```{r}

model1 <- lm(ElOut ~ AmbTemp, data = train_data)

summary(model1)

par(mfrow = c(2,2))

plot(model1)

```


```{r}

model2 <- lm(ElOut ~ ExVac, data = train_data)

summary(model2)

par(mfrow = c(2,2))

plot(model2)

```



```{r}

model3 <- lm(ElOut ~ AmbPress, data = train_data)

summary(model3)

par(mfrow = c(2,2))

plot(model3)

```



```{r}

model4 <- lm(ElOut ~ RelHum, data = train_data)

summary(model4)

par(mfrow = c(2,2))

plot(model4)

```


# Evaluate the Model

* Select a model by noting the R^2 values of the models you built

```{r}

model_names <- c("ElOut vs AmbTemp", "ElOut vs ExVac",
                 "ElOut vs AmbPress", "ElOut vs RelHum")

r2_values <- c(summary(model1)$r.squared, summary(model2)$r.squared,
               summary(model3)$r.squared, summary(model4)$r.squared)

r2 <- cbind(model_names, r2_values)

barplot(r2_values, names.arg = r2[,1], cex.names = 0.78, ylim = c(0, 1),
        main = "A Barplot of R^2 Values of Various Models", xlab = "Models",
        ylab = "Variance in Elec. Output Explained (R^2)")

# The best model, by the r2 scores, is the Elec. output vs Ambient Temperature


```




# Report Performace Metrics

* Construct atleast two performance/evaluation metrics

```{r}

# using the "function()" function, we can create a function which would compute the error if we pass on two parameters to it

mae <- function(actual, predicted){
  
  error <- actual - predicted
  
  mean(abs(error))
  
}

```

```{r}

mse <- function(actual, predicted){
  
  error <- actual - predicted
  
  mean(error^2)
  
}

```

```{r}

rmse <- function(actual, predicted){
  
  error <- actual - predicted
  
  sqrt(mean(error^2))
  
}

```

* Predict Test data based on the chosen model

```{r}

preds <- predict(model1, test_data[, !(names(test_data) %in% c("ElOut"))])
preds1 <- predict.glm(model1, test_data[, !(names(test_data) %in% c("ElOut"))])


```


* Report the performance and final regression formula of the chosen model
*Note:* the formula may change from individual to individual

```{r}

mae(test_data[, "ElOut"], preds)

mse(test_data[, "ElOut"], preds)

rmse(test_data[, "ElOut"], preds)

mae(test_data[, "ElOut"], preds1)

mse(test_data[, "ElOut"], preds1)

rmse(test_data[, "ElOut"], preds1)

```

The final formula for the chosen regression model is:

$$ElOut = 454.2628 - 16.28551\times (ScaledAmbTemp)$$



```{r}

data(mtcars)
M <- cor(mtcars)
##  different color series
col1 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","white",
                           "cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7",
                           "#FFFFFF", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000","red","#FF7F00","yellow","#7FFF7F",
                           "cyan", "#007FFF", "blue","#00007F"))
wb <- c("white","black")


par(ask = TRUE)


## different color scale and methods to display corr-matrix
corrplot(M, method = "number", col = "black", cl.pos = "n")
corrplot(M, method = "number")
corrplot(M)
corrplot(M, order = "AOE")
corrplot(M, order = "AOE", addCoef.col = "grey")

corrplot(M, order = "AOE", col = col1(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, order = "AOE", col = col1(10), addCoef.col = "grey")

corrplot(M, order = "AOE", col = col2(200))
corrplot(M, order = "AOE", col = col2(200), addCoef.col = "grey")
corrplot(M, order = "AOE", col = col2(20), cl.length = 21, addCoef.col = "grey")
corrplot(M, order = "AOE", col = col2(10), addCoef.col = "grey")

corrplot(M, order = "AOE", col = col3(100))
corrplot(M, order = "AOE", col = col3(10))


corrplot(M, method="color", col=col1(20), cl.length=21,order = "AOE", addCoef.col="grey")
corrplot(M, method="square", col=col2(200),order = "AOE")
corrplot(M, method="ellipse", col=col1(200),order = "AOE")
corrplot(M, method="shade", col=col3(20),order = "AOE")
corrplot(M, method="pie", order = "AOE")

## col=wb
corrplot(M, col = wb, order="AOE", outline=TRUE, cl.pos="n")
## like Chinese wiqi, suit for either on screen or white-black print.
corrplot(M, col = wb, bg="gold2",  order="AOE", cl.pos="n")


## mixed methods: It's more efficient if using function "corrplot.mixed"
## circle + ellipse
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="ell",order="AOE",
         diag=FALSE,tl.pos="n", cl.pos="n")

## circle + square
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="square",order="AOE",
         diag=FALSE,tl.pos="n", cl.pos="n")

## circle + colorful number
corrplot(M,order="AOE",type="upper",tl.pos="d")
corrplot(M,add=TRUE, type="lower", method="number",order="AOE",
         diag=FALSE,tl.pos="n", cl.pos="n")

## circle + black number
corrplot(M,order="AOE",type="upper",tl.pos="tp")
corrplot(M,add=TRUE, type="lower", method="number",order="AOE", col="black",
         diag=FALSE,tl.pos="n", cl.pos="n")


## order is hclust and draw rectangles
corrplot(M, order="hclust")
corrplot(M, order="hclust", addrect = 2)
corrplot(M, order="hclust", addrect = 3, rect.col = "red")
corrplot(M, order="hclust", addrect = 4, rect.col = "blue")
corrplot(M, order="hclust", hclust.method="ward", addrect = 4)



## visualize a  matrix in [0, 1]
corrplot(abs(M),order="AOE", cl.lim=c(0,1))
corrplot(abs(M),order="AOE", col=col1(20), cl.lim=c(0,1))
corrplot(abs(M),order="AOE", col=col3(200), cl.lim=c(0,1))


## visualize a  matrix in [-100, 100]
ran <- round(matrix(runif(225, -100,100), 15))
corrplot(ran, is.corr=FALSE)
corrplot(ran, is.corr=FALSE, cl.lim=c(-100, 100))


## text-labels and plot type
corrplot(M, order="AOE", tl.srt=45)
corrplot(M, order="AOE", tl.srt=60)
corrplot(M, order="AOE", tl.pos="d",cl.pos="n")
corrplot(M, order="AOE", diag=FALSE, tl.pos="d")
corrplot(M, order="AOE", type="upper")
corrplot(M, order="AOE", type="upper", diag=FALSE)
corrplot(M, order="AOE", type="lower", cl.pos="b")
corrplot(M, order="AOE", type="lower", cl.pos="b", diag=FALSE)



#### color-legend
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="l")
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="c")
corrplot(M, order="AOE", cl.ratio=0.2, cl.align="r")
corrplot(M, order="AOE", cl.pos="b")
corrplot(M, order="AOE", cl.pos="b", tl.pos="d")
corrplot(M, order="AOE", cl.pos="n")


## deal with missing Values
M2 <- M
diag(M2) = NA
corrplot(M2)
corrplot(M2, na.label = "o")
corrplot(M2, na.label = "NA")


##the input matrix is not square
corrplot(M[1:8,])
corrplot(M[,1:8])



cor.mtest <- function(mat, conf.level = 0.95){
  mat <- as.matrix(mat)
  n <- ncol(mat)
  p.mat <- lowCI.mat <- uppCI.mat <- matrix(NA, n, n)
  diag(p.mat) <- 0
  diag(lowCI.mat) <- diag(uppCI.mat) <- 1
  for(i in 1:(n-1)){
    for(j in (i+1):n){
      tmp <- cor.test(mat[,i], mat[,j], conf.level = conf.level)
      p.mat[i,j] <- p.mat[j,i] <- tmp$p.value
      lowCI.mat[i,j] <- lowCI.mat[j,i] <- tmp$conf.int[1]
      uppCI.mat[i,j] <- uppCI.mat[j,i] <- tmp$conf.int[2]
    }
  }
  return(list(p.mat, lowCI.mat, uppCI.mat))
}

res1 <- cor.mtest(mtcars,0.95)
res2 <- cor.mtest(mtcars,0.99)


## specialized the insignificant value according to the significant level
corrplot(M, p.mat = res1[[1]], sig.level=0.2)
corrplot(M, p.mat = res1[[1]], sig.level=0.05)
corrplot(M, p.mat = res1[[1]], sig.level=0.01)
corrplot(M, p.mat = res1[[1]], insig = "blank")
corrplot(M, p.mat = res1[[1]], insig = "p-value")
corrplot(M, p.mat = res1[[1]], insig = "p-value", sig.level=-1) ## add all p-values
corrplot(M, p.mat = res1[[1]], order="hclust", insig = "blank", addrect=3)
corrplot(M, p.mat = res1[[1]], order="hclust", insig = "pch", addrect=3)



## plot confidence interval(0.95), "square" method
corrplot(M,low=res1[[2]], upp=res1[[3]],
         plotC="circle", addg="grey20",cl.pos="n")
corrplot(M, p.mat = res1[[1]],low=res1[[2]], upp=res1[[3]],
         plotC="circle", addg="grey20",cl.pos="n")
corrplot(M, low=res1[[2]], upp=res1[[3]],
         col=c("white","black"),bg="gold2",order="AOE",
         plotCI="circle",cl.pos="n",pch.col="red")
corrplot(M, p.mat = res1[[1]], low=res1[[2]], upp=res1[[3]],
         col=c("white","black"),bg="gold2",order="AOE",
         plotCI="circle",cl.pos="n",pch.col="red")

## plot confidence interval(0.95), "square" method
corrplot(M, low=res1[[2]], upp=res1[[3]],
         col=c("white","black"),bg="gold2", order="AOE",
         plotCI="square",addg=NULL,cl.pos="n")
corrplot(M, p.mat = res1[[1]],low=res1[[2]], upp=res1[[3]],
         col=c("white","black"),bg="gold2",order="AOE",pch.col="red",
         plotC="square", addg=NULL,cl.pos="n")

## plot confidence interval(0.95, 0.95, 0.99), "rect" method
corrplot(M, low=res1[[2]], upp=res1[[3]], order="hclust",
         rect.col="navy", plotC="rect",cl.pos="n")
corrplot(M, p.mat = res1[[1]], low=res1[[2]], upp=res1[[3]], order="hclust",
         pch.col="red", sig.level = 0.05, addrect=3, rect.col="navy",
         plotC="rect",cl.pos="n")
corrplot(M, p.mat = res2[[1]], low=res2[[2]], upp=res2[[3]], order="hclust",
         pch.col="red", sig.level = 0.01, addrect=3, rect.col="navy",
         plotC="rect",cl.pos="n")


## an animation of changing confidence interval in different significance level
## begin.animaton
par(ask=FALSE)
for(i in seq(0.1, 0, -0.005)){
  tmp <- cor.mtest(mtcars,1-i)
  corrplot(M, p.mat = tmp[[1]], low=tmp[[2]], upp=tmp[[3]], order="hclust",
           pch.col="red", sig.level = i, plotC="rect", cl.pos="n",
           mar=c(0,0,1,0),
           title=substitute(alpha == x,list(x=format(i,digits=3,nsmall=3))))
  Sys.sleep(0.15)
}

```






























